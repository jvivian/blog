---
title: "A Journey Through (Space)Time"
subtitle: "Summary of Classical Mechanics"
author: John Vivian
date: 2024-10-15
format: 
  html:
    # css: styles.css
    toc: true
    toc-depth: 2
    echo: false
editor: visual
execute:
  render-on-save: true
tools:
  - mermaid
---
```{python}
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

plt.style.use('ggplot')
```

> _I do not know what I may appear to the world, but to myself I seem to have been only like a boy playing on the sea-shore, and diverting myself in now and then finding a smoother pebble or a prettier shell than ordinary, whilst the great ocean of truth lay all undiscovered before me_ [^1]

This overview is roughly structured by the concepts I found most profound while reading and researching topics in Sean Carroll's book _The Biggest Ideas in The Universe: Space, Time, and Motion_. 

- While velocity only has meaning in other reference frames, acceleration is _absolute_, and can be identified intriniscally without one (in most cases).
- The squared term in the inverse square law is derived from the spacial geometry we live in (three dimensions).
- Magnetism only exists as a relativistic effect when an object moves relative to an electric field, which helps explain why we have never observed a magnetic monopole.
- The path a particle or system takes is always the most "economical" route through spacetime via minimization/maximization of **action**---a scalar quantity that describes how the balance of kinetic versus potential energy of a physical system changes.
- Conservation laws arise directly from symmetries in the laws of physics. I.e. The invariance of a system's laws relate directly to a given conservation law: time invariance $\rightarrow$ energy conservation, spatial invariance $\rightarrow$ momentum conservation, and rotational symmetry $\rightarrow$ angular momentum conservation.
- The speed of light, $c$, provides a conversion factor between time and space. Like energy $\Leftrightarrow$ mass and electricity $\Leftrightarrow$ magnetism, they are aspects of the same phenomena.
- Lorentz transformations, which describe effects like length contraction and time dilation, can be derived from the invariant spacetime interval---analagous to the Pythagorean theorem---in the geometry of Minkowski space.
- Schwartzchild's solution to General Relativity contained a mathematical singularity -- originally thought to be a _coordinate singularity_ -- turned out to be a real _curvature singularity_ in spacetime: a blackhole.

**Disclaimer**: I’m not a mathematician or physicist, so aim to clarify the meaning of each variable and operator in the equations introduced.

# Acceleration is Absolute

Imagine yourself in deep space, with only distant stars as a backdrop. Would it be possible to tell if you were moving? Nope. As Einstein showed, velocity only has meaning relative to another reference frame. If two people drifted past each other, neither could determine who was stationary or moving, or if they were both moving at once.

Imagine yourself in space with no nearby objects, only distant stars; would it be possible to tell you are moving? Nope. As Einstein later proved, velocity only has context relative to another reference frame. Two people moving in in the same environment past each other would not be able to conclude whether one person was stationary and the other was moving or if both people are moving.

Oddly, _acceleration_ is not the same. If you were suddenly accelerated while in the space suit you would feel it; you would jerk forward, feel the suit push against your chest, etc. The reason for this is acceleration produces a _force gradient_, as opposed to velocity which does not require a force to keep you moving (an object in motion, yada yada...).

You can build your own accelerator-detector just by hanging a weight from a spring. If you begin accelerating left or right, the spring would stretch in the opposite direction. The weight needs to hang to work, because if you turn it sideways the weight will fall towards the ground, even if remain perfectly still. You _are_ accelerating, and have been for quite some time, directly towards the center of the planet. We experience this acceleration as _weight_, which is canceled out by the normal force of the planet pushing back up against us. 


```{python}
#| label: fig-spring_weight_visualization-dffad
#| fig-cap: "Spring with a hanging weight, stretching left as the system accelerates to the right."
# Parameters for the spring and weight
k = 50  # Spring constant (N/m)
mass = 1.0  # Mass of the weight (kg)
g = 9.81  # Gravitational acceleration (m/s^2)
equilibrium_length = 2.0  # Length of the spring at equilibrium (m)

# Calculate displacement caused by the weight’s force
stretch = mass * g / k  # Stretch from the weight’s force on the spring

# Define a wavy line for visualizing the spring
def spring_curve(x: np.ndarray, stretch: float) -> np.ndarray:
    """Generates a wave pattern for visualizing a stretched spring."""
    return np.sin(10 * np.pi * x) * 0.1 - x * stretch

# Generate spring curves for before and after stretching
x = np.linspace(0, 1, 500)  # Position along the spring length
y_unstretched = spring_curve(x, 0)  # Unstretched spring
y_stretched = spring_curve(x, stretch)  # Stretched spring

# Create the figure and axis
fig, ax = plt.subplots(figsize=(6, 8))

# Plot both the unstretched and stretched spring curves
ax.plot(y_unstretched, -x * equilibrium_length, 'k--', alpha=0.5, label='Unstretched Spring')
ax.plot(y_stretched, -x * (equilibrium_length + stretch), 'b-', label='Stretched Spring')

# Represent the weight as a red circle
ax.plot(0, -(equilibrium_length + stretch), 'ro', markersize=15, label='Weight')

# Plot gravitational and spring force vectors
ax.arrow(0, -(equilibrium_length + stretch), 0, -0.5, head_width=0.1, head_length=0.1, 
         fc='blue', ec='blue', label='Gravitational Force $F_g$')
ax.arrow(0, -(equilibrium_length + stretch), 0, 0.5, head_width=0.1, head_length=0.1, 
         fc='green', ec='green', label='Spring Force $F_s$')

# Set plot limits and labels
ax.set_xlim(-0.5, 0.5)
ax.set_ylim(-3.5, 0.5)
ax.set_xlabel('Spring Width')
ax.set_ylabel('Height')

# Add legend
ax.legend(loc='upper right')

# Display the plot
plt.show()
```

Physics equations are extraordinary because they describe _universal relationships_ in the natural world. For instance, the _momentum_ of an object is simply the product of its mass and velocity: $p = mv$. This relationship applies universally to every object with mass and velocity. And I think that's pretty neat [^2]. Notably, the equation shows that momentum is directly proportional to velocity for a constant mass—doubling an object’s velocity doubles its momentum.

[^2]: Neature Walk: https://www.youtube.com/watch?v=Hm3JodBR-vs

## Kinematic Equations
> Moving Through Time: Universal Relationships of Motion

These equations describe universal relationships about an object's motion with constant acceleration—useful for predicting where or how fast something will be at a given time. 

$$v = v_0 + at$$

Velocity increases linearly with time when acceleration is constant

$$s = s_0 + v_0 t + \frac{1}{2} at^2$$

Position grows with time, influenced by both your initial speed and the acceleration 

$$v^2 = v_0^2 + 2a(s - s_0)$$  

The relationship between velocity and distance, without needing time

An interesting consequence to these equations is given position or velocity as a function of time, the equation will predict the function's value for whatever $t$ is. Meaning, these universal relationships do not operate as if the past (fixed from our perspective) is fundamentally different from the future (not-fixed, from our perspective).

::: {.callout-tip collapse="true"}
## What's the point of calculus
Calculus solves two limit-based problems:

1. The goal of the derivative is to find $\frac{dx}{dt}$ as they both approach zero, but you can't divide by zero.
2. The integral attempts to find the sum of the area under the curve as the number of riemann squares approaches infinity.

You can expand a small change in a simple function (such as $x^2$, i.e. $(x+h)^2 - x^2$) and work out as the limit $h \rightarrow 0$, you get $2x$.
:::

:::{.callout-note collapse="true"}
## Kinematic Derivation
The kinematic equations can be derived from the basic definition of calculus. Given a change in position over time is velocity:
$$\frac{dx}{dt} = v$$

we want to express $v$ in terms of $t$, since that also changes over time.

$$v(t) = v_0 + at$$

Reformulate velocity as the first time derivative of position

$$\frac{dx}{dt} = v_0 + at$$

Then integrate with respect to time

$$x(t) = \int (v_0 + at) dt$$

Solving for the integral gives us

$$x(t) = v_0t + \frac{1}{2}at^2 + C$$

Where C would represent whatever the **initial position** is, which we can call $x_0$. This gives us

$$x(t) = x_0 + v_0t + \frac{1}{2}at^2$$

You can plug this equation into $v = v_0 + at$ and do some math to get:

$$v^2 = v_0^2 + 2a(x-x0)$$
:::

## The Universal Law of Gravitation

```{python}
#| label: fig-gravitational_force_visualization
#| fig-cap: Force vectors (equal and opposite for each mass) generated as a result of their respective masses and distance.
# Gravitational constant (arbitrary scale for visualization)
G = 1.0

# Masses of two objects
m1 = 6.0  # Mass of first object
m2 = 2.0  # Mass of second object

# Positions of the two masses
x1, y1 = -1, 0  # Position of mass 1
x2, y2 = 1, -2   # Position of mass 2

# Distance between the two masses
r = round(np.sqrt((x2 - x1)**2 + (y2 - y1)**2), 2)

# Calculate the force magnitude using Newton's law of gravitation
F = G * (m1 * m2) / r**2

# Unit vector for the direction of the force
dx, dy = (x2 - x1) / r, (y2 - y1) / r

# Create the figure and axis
fig, ax = plt.subplots(figsize=(8, 6))

# Plot the two masses as circles
ax.plot(x1, y1, 'ro', markersize=m1 * 5, label=f'$m_1$: {m1}')
ax.plot(x2, y2, 'bo', markersize=m2 * 5, label=f'$m_2$: {m2}')

# Plot force vectors (equal and opposite)
ax.arrow(x1, y1, F * dx, F * dy, head_width=0.1, head_length=0.2, 
         fc='red', ec='red', label='Gravitational Force on $m_1$')
ax.arrow(x2, y2, -F * dx, -F * dy, head_width=0.1, head_length=0.2, 
         fc='blue', ec='blue', label='Gravitational Force on $m_2$')

# Set plot limits
# ax.set_xlim(-3, 3)
# ax.set_ylim(-2, 2)

# Add labels, title, and legend
ax.set_xlabel('x')
ax.set_ylabel('y')
# ax.set_title(f"Gravitational force vectors - Distance: {r}")
ax.legend(loc='upper right')

# Display the plot
plt.show()
```

Newton's Universal Law of Gravitation describes the generated by two masses. This equation also ties together the inverse square law (decay of intensity of effects such as light, radiation, or gravity). 

$$F = G\frac{m_1m_2}{r^2}$$

- $F$ is the gravitational force between two masses.
- $G$ is the gravitational constant.
- $m_1$ and $m_2$ are the masses of the two objects.
- $r$ is the distance between the centers of the two masses.

Why is $r$ squared? Why not quadrupled or halved? The inverse square relationship emerges as a property of living in three dimensions. The volume of a sphere increases with the square of the radius: $4\pi r^2$.

# Maxwell's Equations
> Quote here

Maxwell's Equations elegantly describe the behavior of electric and magnetic fields, revealing that these two forces are not separate but deeply interconnected. They provide a unified framework for understanding how electric charges and currents create fields that interact, propagate, and influence each other, ultimately giving rise to light itself. 

## **Gauss's Law (Electric Field)**

$$\nabla \cdot \mathbf{E} = \frac{\rho}{\epsilon_0}$$

:::{.callout-note collapse="true"}
## Understanding the Del Operator ($\nabla$) in Maxwell’s Equations

The **del operator** ($\nabla$) is a vector operator that captures how quantities change in space, and it’s central to expressing Maxwell’s equations in a compact, powerful form. 

1. **Gradient ($\nabla \phi$)**: When applied to a scalar field $\phi$, $\nabla$ (del) gives the **gradient**, pointing in the direction of the greatest rate of change. For example, in an electric potential field $\phi$, the gradient $\vec{E} = -\nabla\phi$ tells us how the electric field varies in space.

2. **Divergence ($\nabla \cdot$)**: When $\nabla$ is applied to a vector field with a dot product ($\nabla \cdot$), it gives the **divergence**. Divergence measures the “outflow” or “inflow” of a field at a point:
   - **Gauss’s Law for Electricity** $(\nabla·\vec{E} = \frac{ρ}{ε_0})$: This tells us that the electric field $\vec{E}$ diverges from electric charges.
   - **Gauss’s Law for Magnetism** $(\nabla·\vec{B} = 0)$: This shows that magnetic field lines have no divergence—they form closed loops, indicating no magnetic monopoles.

3. **Curl ($\nabla \times$)**: When $\nabla$ is applied to a vector field with a cross product ($\nabla \times$), it gives the **curl**, measuring the “rotation” or “circulation” of a field:
   - **Faraday’s Law** $(\nabla×\vec{E} = -\frac{∂\vec{B}}{∂t})$: A changing magnetic field $\vec{B}$ induces a circulating electric field $\vec{E}$.
   - **Ampère’s Law (with Maxwell’s Correction)** $(\nabla×\vec{B} = μ_0\vec{J} + μ_0ε_0\frac{∂\vec{E}}{∂t})$: A changing electric field $\vec{E}$ or current density $\vec{J}$ induces a circulating magnetic field $\vec{B}$.

### Summary:
The del operator ($\nabla$) is a vector operator that operates on a:
- **Gradient ($\nabla\phi$)**: scalar field, producing a vector field.
- **Divergence ($\nabla\cdot$)**: vector field, producing a scalar field.
- **Curl ($\nabla\times$)**: vector field, producing a vector field.
:::


Gauss's Law describes the relationship between electric charges and the electric field they produce. Specifically, it states that the electric flux (the "flow" of the electric field) through a closed surface is proportional to the total charge enclosed within that surface. For example, the electric field around a point charge (like an electron) points away from the charge if it's positive, and towards the charge if it's negative. The strength of the field is directly related to the amount of charge.

- $\nabla \cdot \mathbf{E}$: This is the divergence of the electric field $\mathbf{E}$, which essentially measures how much the electric field is "spreading out" from a point.
- $\rho$: This represents the **charge density** (charge per unit volume). The more charge you have in a given region, the stronger the electric field diverges from that region.
- $\epsilon_0$: This is the **permittivity of free space**, a constant that determines how electric fields interact in a vacuum.

```{python}
#| label: fig-gauss_law_electric
#| fig-cap: "Gauss's Law for Electricity: Electric Field Lines Around Charges"
# Create a grid for the field
x, y = np.meshgrid(np.linspace(-2, 2, 400), np.linspace(-2, 2, 400))

# Define charge positions and magnitudes (positive and negative)
charges = [(1, (0.5, 0)), (-1, (-0.5, 0))]

# Initialize the electric field vectors
Ex, Ey = np.zeros(x.shape), np.zeros(y.shape)

# Loop over the charges and calculate the contribution to the field
for charge, (cx, cy) in charges:
    r = np.sqrt((x - cx)**2 + (y - cy)**2)
    Ex += charge * (x - cx) / r**3
    Ey += charge * (y - cy) / r**3

# Plot the electric field lines
plt.figure(figsize=(6, 6))
plt.streamplot(x, y, Ex, Ey, color=np.sqrt(Ex**2 + Ey**2), linewidth=1)
plt.plot(0.5, 0, 'ro', markersize=10, label='Positive Charge')
plt.plot(-0.5, 0, 'bo', markersize=10, label='Negative Charge')

# Labels and title
plt.title("Gauss's Law for Electricity")
plt.legend()
plt.show()
```


##  **Gauss's Law for Magnetism**

$$\nabla \cdot \mathbf{B} = 0$$

This law states that there are **no magnetic monopoles** — that is, no isolated north or south magnetic poles. Magnetic fields ($\mathbf{B}$) always form closed loops. Every magnetic field line that leaves a north pole must eventually return to a south pole.

- $\nabla \cdot \mathbf{B}$: This is the divergence of the magnetic field $\mathbf{B}$, which measures how much the magnetic field is "spreading out" from a point.
- The fact that it's equal to zero means that the net magnetic "flux" through any closed surface is always zero, implying that magnetic field lines don’t begin or end at any point (unlike electric fields, which start or end on charges).

```{python}
#| label: fig-magnetic
#| fig-cap: Magnetic field lines around a magnetic point

# Grid for the contour plot
x = np.linspace(-3, 3, 100)
y = np.linspace(-3, 3, 100)
X, Y = np.meshgrid(x, y)

# Calculate a hypothetical magnetic dipole field in 2D for visualization
# Assuming a simple dipole approximation
B_x = -Y / (X**2 + Y**2)**1.5  # Field component in x direction
B_y = X / (X**2 + Y**2)**1.5  # Field component in y direction

# Magnitude of the field for contour levels
B_magnitude = np.sqrt(B_x**2 + B_y**2)

# Create the contour plot
fig, ax = plt.subplots(figsize=(8, 8))

# Plot the field lines as contours
contour = ax.contour(X, Y, B_magnitude, levels=10, cmap="viridis", alpha=0.75)
ax.clabel(contour, inline=True, fontsize=8, fmt="%.2f")

# Add streamplot to show the direction of the magnetic field
ax.streamplot(X, Y, B_x, B_y, color="darkred", linewidth=1, density=1.5, arrowsize=1.5)

# Plot Gaussian surface as a dashed circle to emphasize the zero net flux
surface_radius = 2.5
theta = np.linspace(0, 2 * np.pi, 100)
x_surface = surface_radius * np.cos(theta)
y_surface = surface_radius * np.sin(theta)
ax.plot(x_surface, y_surface, 'k--', label="Gaussian Surface")

# Annotate the North and South poles for reference
ax.text(0, 2.8, "N", ha='center', va='center', fontsize=14, color='blue')
ax.text(0, -2.8, "S", ha='center', va='center', fontsize=14, color='blue')

# Labels, legend, and aesthetic adjustments
ax.legend(loc="upper right")
ax.axis("equal")
ax.axis("off")

# Display the plot
plt.show()
```


## **Faraday's Law of Induction**
$$\nabla \times \mathbf{E} = -\frac{\partial \mathbf{B}}{\partial t}$$

**Meaning:**
Faraday’s Law explains how a changing magnetic field creates an electric field. If you have a time-varying magnetic field ($\mathbf{B}$), it induces a circulating electric field ($\mathbf{E}$). This is the principle behind electromagnetic induction, which is used in transformers and electric generators. When a magnet is spun around near a coil of wire, the changing magnetic field induces an electric current in the wire, which we can then use as electrical power.

- **$\nabla \times \mathbf{E}$**: This is the curl of the electric field $\mathbf{E}$, which measures how much the electric field is "circulating" around a point.
- **$\frac{\partial \mathbf{B}}{\partial t}$**: This is the time rate of change of the magnetic field. It represents how the magnetic field is changing in time.
- The negative sign indicates that the induced electric field opposes the change in the magnetic field (this is Lenz's law).

```{python}
#| label: fig-faraday
#| fig-cap: Changing magnetic fields induce electric fields

import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

# Set up the figure and 3D axes with ggplot style
plt.style.use('ggplot')
fig = plt.figure(figsize=(10, 6))
ax = fig.add_subplot(111, projection='3d')

# Parameters for the waves
x = np.linspace(0, 20, 1000)  # Position along the propagation direction (x-axis)
k = 2 * np.pi / 5             # Wave number
omega = 2 * np.pi / 5         # Angular frequency
t = 0                         # Time (static snapshot)
E0 = 1                        # Electric field amplitude
B0 = 1                        # Magnetic field amplitude

# Calculate the electric and magnetic fields as sinusoidal waves
E = E0 * np.sin(k * x - omega * t)  # Electric field (along y-axis)
B = B0 * np.sin(k * x - omega * t)  # Magnetic field (along z-axis)

# Plot the electric field
ax.plot(x, E, np.zeros_like(x), color='blue', label='Electric Field (E)', linewidth=2)
# Plot the magnetic field
ax.plot(x, np.zeros_like(x), B, color='red', label='Magnetic Field (B)', linewidth=2)

# Add a dotted arrow along the x-axis to represent the direction of wave propagation
ax.plot(x, np.zeros_like(x), np.zeros_like(x), 'k--', label='Propagation Direction (x)', linewidth=1.5)

# Customize the view angle for a clear perspective
ax.view_init(elev=30, azim=60)

# Labels and legend for clarity
ax.set_xlabel('Propagation Direction (x)', fontsize=12)
ax.set_ylabel('Electric Field (E)', fontsize=12)
ax.set_zlabel('Magnetic Field (B)', fontsize=12)
ax.legend(fontsize=12)

# Minimalist aesthetics: turn off grid panes for a cleaner look
ax.grid(False)
ax.xaxis.pane.fill = False
ax.yaxis.pane.fill = False
ax.zaxis.pane.fill = False
ax.xaxis.pane.set_edgecolor('w')
ax.yaxis.pane.set_edgecolor('w')
ax.zaxis.pane.set_edgecolor('w')
ax.set_xticks([])
ax.set_yticks([])
ax.set_zticks([])

# Show the plot
plt.tight_layout()
plt.show()
```


## **Ampère's Law (with Maxwell’s Correction)**

$$\nabla \times \mathbf{B} = \mu_0 \mathbf{J} + \mu_0 \epsilon_0 \frac{\partial \mathbf{E}}{\partial t}$$

- $\nabla \times \mathbf{B}$: This is the curl of the magnetic field $\mathbf{B}$, which measures how much the magnetic field "circulates" around a point.
- $\mathbf{J}$: This is the **current density** (current per unit area).
- $\frac{\partial \mathbf{E}}{\partial t}$: This represents the rate of change of the electric field in time.

Ampère’s Law relates electric currents and changing electric fields to the magnetic field they produce. It says that magnetic fields can be generated in two ways:

- By electric currents (moving charges), as described by the first term, $\mu_0 \mathbf{J}$.
- By changing electric fields, as described by the second term, $\mu_0 \epsilon_0 \frac{\partial \mathbf{E}}{\partial t}$, which is called the **displacement current** (introduced by Maxwell).

Ampère’s Law with Maxwell’s correction tells us that **currents** (moving charges) and **changing electric fields** generate magnetic fields. Without the time-dependent term $\frac{\partial \mathbf{E}}{\partial t}$, this would just be the original Ampère’s Law, which describes how an electric current creates a magnetic field (like in an electromagnet). Maxwell’s addition was crucial because it showed that even in the absence of a physical current, a changing electric field can still produce a magnetic field.

```{python}
#| label: fig-ampere
#| fig-cap: The opposite of Faraday's Law - a time-varying electric field is the source of an induced magnetic field.
# Re-plotting with only "dE/dt" to emphasize the time-varying electric field as the source of the induced magnetic field

# Set up the figure with ggplot style for aesthetics
fig, ax = plt.subplots(figsize=(8, 8))
ax.set_aspect('equal')

# Define parameters for the capacitor plates and electric field lines
plate_width = 1.0
plate_length = 4.0
plate_offset = 1.5

# Plot the capacitor plates with color-coded charges
ax.plot([-plate_length / 2, plate_length / 2], [plate_offset, plate_offset], color='red', lw=4, label="Capacitor Plate (+)")
ax.plot([-plate_length / 2, plate_length / 2], [-plate_offset, -plate_offset], color='black', lw=4, label="Capacitor Plate (-)")

# Electric field lines between capacitor plates (vertical lines indicating field change)
for i in np.linspace(-plate_length / 2, plate_length / 2, 6):
    ax.arrow(i, -plate_offset, 0, 2 * plate_offset, head_width=0.1, head_length=0.2, fc='blue', ec='blue')

# Magnetic field lines (circling the changing electric field in the gap)
theta = np.linspace(0, 2 * np.pi, 100)
for radius in [2.2, 2.7, 3.2]:  # Multiple circles for the magnetic field lines
    x = radius * np.cos(theta)
    y = radius * np.sin(theta)
    ax.plot(x, y, color='orange', linestyle='--', lw=1.5, alpha=0.8, label="Induced Magnetic Field" if radius == 2.2 else "")

# Annotation to highlight the changing electric field (dE/dt)
ax.text(0, -plate_offset - 0.5, "dE/dt (Changing Electric Field)", ha='center', color='blue', fontsize=12)
ax.text(3.5, 0, "B (Induced Magnetic Field)", color='orange', fontsize=12, rotation=90)

# Minimalist aesthetics
ax.axis("off")
ax.legend(loc="upper right")

# Display the plot
plt.tight_layout()
plt.show()
```

### The Bigger Picture: Electromagnetic Waves
Maxwell’s equations, taken together, explain how electric and magnetic fields interact and propagate. If you combine Faraday's Law and Ampère’s Law, you can derive the **wave equation** for both electric and magnetic fields, showing that disturbances in these fields propagate at the speed of light. Together, these two effects allow electromagnetic waves to propagate through space, with the electric and magnetic fields continuously regenerating each other.

This is why light, radio waves, X-rays, and all other electromagnetic radiation are essentially **electromagnetic waves**: oscillating electric and magnetic fields that move through space, even in a vacuum.


# Lagrangian and Hamiltonian Mechanics
> Different ways to tell the same (Newtonian) story

In Newtonian mechanics, where $F = ma$, we focus on forces acting at a specific point in space and time to answer "What happens at the next $t$?" This approach helps us understand motion in terms of **forces** and **accelerations**.

In contrast, mechanics based on action principles---Lagrangian and Hamiltonian mechanics---start from a different perspective, emphasizing the concept of **action**. Action represents an energy tradeoff between kinetic and potential energy, shaped by the system's physical properties. Instead of predicting the immediate "next step," these approaches answer questions about _paths_, e.g. which trajectory will efficiently guide a rocket to the moon?

In lieu of forces, Lagrangian and Hamiltonian mechanics prioritize **paths, energy, and phase space**. Phase space, in particular, provides a powerful framework for visualizing the state of a system and plays a central role in fields like quantum mechanics and field theory.

To see these differences in action, we can visualize a classical physical system---the **simple harmonic oscillator**---through the lenses of Newtonian, Lagrangian, and Hamiltonian mechanics.

::: {.callout-note collapse="true"}
## Simple Harmonic Oscillator

The **Simple Harmonic Oscillator** is a fundamental model of periodic motion, where an object experiences a restoring force proportional to its distance from an equilibrium position. This force always acts toward the equilibrium, driving the object back whenever it is displaced.

```{python}
#| label: fig-SHO
#| fig-cap: This mass-spring system illustrates the concept of a simple harmonic oscillator, where the restoring force is proportional to displacement. This same principle applies in other contexts such as pendulums, which exhibit harmonic motion at small angles. LC circuits, oscillate energy between electric and magnetic fields. This even extends to quantum harmonic oscillator models which models particles in a potential well.

fig, ax = plt.subplots(figsize=(8, 4))

# Parameters for the mass-spring system visualization
spring_length = 1.0  # length of the spring at rest
displacement = 0.5   # displacement from equilibrium
mass_position = spring_length + displacement  # position of the mass due to displacement

# Draw the spring as a sinusoidal curve
spring_x = np.linspace(0, spring_length + displacement, 100)
spring_y = 0.1 * np.sin(10 * np.pi * spring_x / (spring_length + displacement))  # Wavy pattern for spring effect
ax.plot(spring_x, spring_y, color='black', linewidth=2, label="Spring")

# Draw the mass as a box
mass_width, mass_height = 0.2, 0.2
mass_x = [mass_position - mass_width / 2, mass_position + mass_width / 2, 
          mass_position + mass_width / 2, mass_position - mass_width / 2, 
          mass_position - mass_width / 2]
mass_y = [-mass_height / 2, -mass_height / 2, mass_height / 2, mass_height / 2, -mass_height / 2]
ax.fill(mass_x, mass_y, color='gray', label="Mass")

# Indicate equilibrium position with a dashed line
ax.axvline(spring_length, color='blue', linestyle='--', linewidth=1)
ax.text(spring_length, 0.25, 'Equilibrium Position', color='blue', ha='center', fontsize=10)

# Draw restoring force arrow
ax.arrow(mass_position, 0, -0.3, 0, head_width=0.05, head_length=0.1, fc='red', ec='red', label="Restoring Force")
ax.text(mass_position - 0.35, 0.05, r"$F = -kx$", color='red', fontsize=12)

# Annotate displacement
ax.annotate("Displacement (x)", xy=(mass_position - displacement / 2, 0.2), xytext=(mass_position + 0.2, 0.3),
            arrowprops=dict(facecolor='black', arrowstyle="->"), fontsize=10)

# Axis limits and labels
ax.set_xlim(0, spring_length + displacement + 0.5)
ax.set_ylim(-0.5, 0.5)
ax.axis("off")  # Turn off axis for a clean look

# Legend and Display
plt.legend(loc="upper left", fontsize=10)

# Show the plot
plt.show()
```

:::


```{python}
#| label: fig-corrected_mechanics_comparison
#| fig-cap: "Comparison of Newtonian, Lagrangian, and Hamiltonian Mechanics for a simple harmonic oscillator"
from scipy.integrate import solve_ivp
# Parameters for the harmonic oscillator
m = 1.0   # Mass (kg)
k = 1.0   # Spring constant (N/m)
omega = np.sqrt(k / m)  # Angular frequency
A = 1.0  # Amplitude of oscillation

# Newtonian mechanics: F = ma = -kx
def newtonian_acceleration(x: np.ndarray) -> np.ndarray:
    return -omega**2 * x

# Hamiltonian mechanics: Phase space dynamics
def hamiltonian_system(t: float, y: np.ndarray) -> np.ndarray:
    q, p = y  # Position and momentum
    dqdt = p / m  # dx/dt = p / m
    dpdt = -k * q  # dp/dt = -kx
    return [dqdt, dpdt]

# Solve Hamiltonian system for phase space trajectory
sol = solve_ivp(hamiltonian_system, [0, 10], [A, 0], t_eval=np.linspace(0, 10, 500))

# Lagrangian path: Position over time assuming maximum displacement at t=0
time = np.linspace(0, 10, 100)
x_lagrangian = A * np.cos(omega * time)  # Expected path for least action

# Create figure with subplots
fig, axs = plt.subplots(3, figsize=(8, 10))

# 1. Newtonian mechanics: Acceleration vs. Position
x = np.linspace(-A, A, 100)  # Position range for the oscillator
axs[0].plot(x, newtonian_acceleration(x), color='blue')
axs[0].set_title('Newtonian Mechanics: F = ma')
axs[0].set_xlabel('Position ($x$)')
axs[0].set_ylabel('Acceleration ($a$)')
axs[0].axhline(0, color='black', lw=0.8)  # Equilibrium acceleration line

# 2. Lagrangian mechanics: Path over time
axs[1].plot(time, x_lagrangian, color='green')
axs[1].set_title('Lagrangian Mechanics: Path Minimization')
axs[1].set_xlabel('Time ($t$)')
axs[1].set_ylabel('Position ($x$)')
axs[1].axhline(0, color='black', lw=0.8)  # Equilibrium line

# 3. Hamiltonian mechanics: Phase space trajectory
axs[2].plot(sol.y[0], sol.y[1], color='red')
axs[2].set_title('Hamiltonian Mechanics: Phase Space')
axs[2].set_xlabel('Position ($q$)')
axs[2].set_ylabel('Momentum ($p$)')
axs[2].axhline(0, color='black', lw=0.8)  # Zero momentum line
axs[2].axvline(0, color='black', lw=0.8)  # Zero position line

# Adjust layout and display plot
plt.suptitle('Comparison of Newtonian, Lagrangian, and Hamiltonian Mechanics')
plt.tight_layout()
plt.show()

```

## The Action Integral
> The profound economy of Nature

The action integral $S$ is the "score" of a given path taken by a system between two points in time.

$$S[q(t)] = \int_{t_1}^{t_2} L(q, \dot{q}, t) \, dt$$

- $S[q(t)]$ is the _action_ which depends on the path $q(t)$
- $L(q, \dot{q}, t)$ is the **Lagrangian**, which is the difference between the kinetic energy $T$ and potential energy $V$
- Note: Dot notation above a variable represents its first derivative. Two dots for the second derivative.

$$L = T - V$$

In essence, the action integral sums up the Lagrangian $L$ over a specific path from $t_1$ to $t_2$. This principle of minimizing the action is known as the _principle of least action_, and it gives us the most efficient or "natural" path a system will take.

### The Euler-Lagrange Equation

We're still missing one component---a condition that allows us to minimize the Lagrangian. Thankfully someone way smarter than any of us worked out the rather elegant solution, the **Euler-Lagrange equation**:

$$\frac{d}{dt} \left( \frac{\partial L}{\partial \dot{q}} \right) - \frac{\partial L}{\partial q} = 0$$

- **$\frac{\partial L}{\partial \dot{q}}$**: This is the **partial derivative of the Lagrangian with respect to the velocity** $\dot{q}$. It measures how sensitive the Lagrangian is to changes in the system's velocity.
- **$\frac{d}{dt} \left( \frac{\partial L}{\partial \dot{q}} \right)$**: This term takes the time derivative of the above quantity, capturing how this sensitivity changes as the system evolves over time.
- **$\frac{\partial L}{\partial q}$**: This is the **partial derivative of the Lagrangian with respect to position** $q$. It measures how sensitive the Lagrangian is to changes in the system's position.

The **Euler-Lagrange equation** tells us that, for the actual path taken by the system, these two rates of change are equal and opposite.

#### Intuition Behind the Equation

The Euler-Lagrange equation is the mathematical expression of the **principle of least action**. It provides the conditions under which the action $S$ is minimized. 

To build intuition around this concept, let's imagine a ball rolling down a _frictionless_ hill.

When the ball starts at the top of the hill, it has maximum potential energy (due to height and the acceleration from gravity) and zero kinetic energy (energy due to motion). As it begins rolling down, gravity pulls it lower, decreasing its potential energy. But energy can’t just disappear—instead, it converts into kinetic energy, causing the ball to speed up.

The ball follows a path where potential energy smoothly turns into kinetic energy as it descends. The principle of least action explains this smooth exchange by "favoring" paths where energy changes are gradual and balanced.

When the ball reaches the bottom, it’s out of hill to roll down. Its potential energy is minimized, and all the energy it gained from descending has been converted into kinetic energy. 

This trade-off between potential and kinetic energy is natural because it minimizes abrupt changes in energy. A path where energy flowed in sharp bursts or stopped suddenly would require additional forces or disruptions. A smooth path minimizes these disturbances, making it the most efficient in terms of conserving energy while following the laws of physics.

If this process sounds similar to **heat diffusion**, you're doin good baby. Both are examples of the Universe's tendency towards _equilibrium_ while maintaining _conservation_.

::: {.callout-tip}
## TLDR
Any change in kinetic energy is exactly offset by an opposite change in potential energy, and vice versa. 
:::


::: {.callout-note collapse="true"}
## The Action of Simple Harmonic Motion

To see the action integral in action (hehe), let’s examine a **simple harmonic oscillator**, such as a mass attached to a spring and solve for the Lagrangian.

**Kinetic Energy $T$**

For an object of mass $m$ moving with velocity $\dot{q}$, the kinetic energy $T$ is given by:
$$T = \frac{1}{2} m \dot{q}^2$$

**Potential Energy $V$**

For a spring with spring constant $k$, the potential energy $V$ depends on the displacement $q$ from equilibrium:
$$V = \frac{1}{2} k q^2$$

**Lagrangian $L = T - V$**  

Substituting the expressions for $T$ and $V$:

$$L = T - V = \frac{1}{2} m \dot{q}^2 - \frac{1}{2} k q^2$$

**Action Integral**

To find the path $q(t)$ that the system takes between times $t_1$ and $t_2$, we evaluate the action integral:
$$S[q(t)] = \int_{t_1}^{t_2} \left( \frac{1}{2} m \dot{q}^2 - \frac{1}{2} k q^2 \right) \, dt$$

**Finding the Path (Euler-Lagrange Equation)**

Applying the **Euler-Lagrange equation** to the Lagrangian leads to the equation of motion:
$$\frac{d}{dt} \left( \frac{\partial L}{\partial \dot{q}} \right) - \frac{\partial L}{\partial q} = 0$$

Solving this gives the differential equation for a simple harmonic oscillator:
$$m \ddot{q} + k q = 0$$

which has solutions in the form of sinusoidal functions, describing the oscillatory motion $q(t)$ over time.

::: {.callout-warning collapse="true"}
## Hey not so fast, where the hell is $q(t)$?
Ok, ok sorry. I tried to pull a fast one. Solving the Lagrangian only gave us this differential equation—it didn’t directly give us the solution for 
$q(t)$, which is the explicit path or trajectory of the system over time. 

We can rewrite our solution as

$$\ddot{q} + \frac{k}{m}q=0$$


Let $\omega = \sqrt{\frac{k}{m}}$, where $\omega$ is the **angular frequency** of the oscillator. Now the equation becomes:
$$\ddot{q} + \omega^2 q = 0$$

This equation has a general solution of the form:
$$q(t) = A \cos(\omega t) + B \sin(\omega t)$$
where $A$ and $B$ are constants determined by the initial conditions of the system (such as initial position and velocity).

::: {.callout-important collapse="true"}
## But wait, why is that the general solution?
Oh my god fuck off already
:::

### Interpretation
This solution, $q(t) = A \cos(\omega t) + B \sin(\omega t)$, is the explicit **time-dependent path** or **trajectory** that the oscillator follows. It describes the oscillatory motion in terms of time, with:

- $\omega$: The frequency of oscillation, showing how quickly the system oscillates.
- $A$ and $B$: Constants that depend on the starting conditions (e.g., where and how fast the mass was initially moving).
:::

If you squint, you'll see we've derived **Hooke's Law**. Since $\ddot{q} = a$ and $F=ma$:

$$ ma = F = - kq $$

where $k$ is the _spring constant_ AKA restoring force over the distance ($\frac{N}{m}$).


:::

## The Hamiltonian Reform(ul)ation
> Puttin' big E first

We spent a a bit of time on Lagrangian mechanics because it also requires introduces several other interesting concepts like _the principle of least action_. The good news is we've done a lot of the heavy lifting and there's nothing too crazy about now thinking about Hamiltonian mechanics, where we shift from _paths_ to _energies_.

While the Lagrangian $L = T - V$ is built around action, the Hamiltonian is a powerful reformulation that shifts the focus to energy. The Hamiltonian $H$ typically represents the total energy of a system $H = T + V$ (kinetic + potential energy) and is built to highlight conservation laws.

Unlike the Lagrangian, the Hamiltonian only depends on the position $q$ and momentum $p$, but not directly on $t$ itself. This approach introduces **phase space** (a space defined by positions and momenta), allowing viusalization of a system’s entire state at any moment. Shifting from position/velocity to position/momentum reveals insights about stability, resonance, and even chaotic behavior in systems.

Reviewing @fig-corrected_mechanics_comparison now may be elucidating. First, the phase space for the simple harmonic oscillator shows energy is conserved (closed ellipse). Second, thinking back to our ball-on-a-hill example and starting from the left and rolling down hill to the right, would hit maximum momentum at the bottom of the hill ($x=0$) and as it oscillated forever back-and-forth would follow a clockwise path around the ellipse (rolling back to where we started in this coordinate system means negative velocity therefore negative momentum).

::: {.callout-note collapse="true"}
## Simple Harmonic Hamiltonian
> Here we can shortcut since we already did the Lagrangian solution.

$$L = T - V = \frac{1}{2} m \dot{q}^2 - \frac{1}{2} k q^2$$

**Define the Hamiltonian $H = T + V$ in Terms of Position and Momentum**

To switch to the Hamiltonian formalism, we need to express the system in terms of **position $q$** and **momentum $p$**, where momentum $p$ is defined as:
$$p = \frac{\partial L}{\partial \dot{q}} = m \dot{q}$$

Now, let’s express the **Hamiltonian** $H$, which for many systems is the **total energy** $T + V$:
$$H = T + V = \frac{p^2}{2m} + \frac{1}{2} k q^2$$

So, the Hamiltonian for a simple harmonic oscillator is:
$$H(q, p) = \frac{p^2}{2m} + \frac{1}{2} k q^2$$

**Interpret the Hamiltonian**

The Hamiltonian here represents the **total energy** of the oscillator, with:

- $\frac{p^2}{2m}$: The **kinetic energy** in terms of momentum $p$
- $\frac{1}{2} k q^2$: The **potential energy** stored in the spring

**Derive the Equations of Motion Using Hamilton’s Equations**

In Hamiltonian mechanics, we use **Hamilton’s equations** to describe the time evolution of the system:

$$\dot{q} = \frac{\partial H}{\partial p} \quad \text{and} \quad \dot{p} = -\frac{\partial H}{\partial q}$$

Applying these to our Hamiltonian:
1. **Find $\dot{q}$**:
   $$\dot{q} = \frac{\partial H}{\partial p} = \frac{p}{m}$$
   This confirms our definition of momentum, $p = m \dot{q}$.

2. **Find $\dot{p}$**:
   $$\dot{p} = -\frac{\partial H}{\partial q} = -k q$$
   This gives us the familiar equation of motion for a simple harmonic oscillator:
   $$m \ddot{q} + k q = 0$$

**Visualizing in Phase Space**

The Hamiltonian approach naturally introduces **phase space**, where each point represents a state of the system with coordinates $(q, p)$. For a simple harmonic oscillator:
- The system’s trajectory in phase space forms an **ellipse**.
- This elliptical trajectory represents the **conservation of total energy**: as the oscillator moves, $q$ and $p$ oscillate back and forth, but the total energy (Hamiltonian) remains constant.

This example highlights the power of the Hamiltonian formalism in tracking **conserved quantities** and understanding **system behavior** in phase space.
:::

# Minkowski Space
> _Roads? Where we're going, we don't need roads_ [^3]

[^3]: Dr. Emmmet Brown - Back to the Future

```{python}
#| label: fig-minkowski_light_cone
#| fig-cap: Light Cone in Minkowski Space. A stationary observer moves vertically along a 'World Line'
fig, ax = plt.subplots(figsize=(8, 8))

# Plot the light cone (x = ±ct)
t = np.linspace(-5, 5, 100)
ax.plot(t, t, linestyle='--', color='orange', label='Light Cone: $x = ct$')
ax.plot(t, -t, linestyle='--', color='orange')

# Plot the observer's worldline (stationary at x = 0)
ax.plot([0, 0], [-5, 5], color='blue', lw=2, label='Worldline of Observer')

# Plot space and time axes
ax.axhline(0, color='black', lw=1)  # Space axis
ax.axvline(0, color='black', lw=1)  # Time axis

# Annotate causal regions
ax.text(2.5, 2.5, 'Future', fontsize=12, color='green', ha='center')
ax.text(-2.5, -2.5, 'Past', fontsize=12, color='red', ha='center')
ax.text(3.5, -0.5, 'Elsewhere', fontsize=12, color='gray', ha='center')

# Set labels and limits
ax.set_xlabel('Space ($x$)')
ax.set_ylabel('Time ($t$)')
ax.set_title('Minkowski Space: Light Cone of an Observer')

# Set plot limits for symmetry
ax.set_xlim(-5, 5)
ax.set_ylim(-5, 5)

# Add legend
ax.legend(loc='upper right')

# Display plot
plt.show()

```

```{python}
#| label: fig-pythag
#| fig-cap: Real Time in Minkowski space

fig, ax = plt.subplots(figsize=(8, 8))

# Define the light cone (45-degree lines) for reference
x = np.linspace(-10, 10, 400)
t = np.abs(x)  # Light moves at 45 degrees, so t = |x|

# Plot the light cone as dashed lines
ax.plot(x, t, 'k--', alpha=0.5, label="Light Path (c)")
ax.plot(x, -t, 'k--', alpha=0.5)

# Coordinates for an example object moving slower than light
x_object = 6
t_object = 8
s_object = np.sqrt((t_object)**2 - (x_object)**2)  # Proper time (tau), the hypotenuse

# Draw the object’s path
ax.plot([0, x_object], [0, t_object], color='blue', label="Object Path")
ax.plot([0, x_object], [0, 0], 'b:', linewidth=1)  # Projected x-component
ax.plot([x_object, x_object], [0, t_object], 'b:', linewidth=1)  # Projected t-component

# Draw the hypotenuse representing real time (proper time)
ax.annotate(r"$\tau$ (Proper Time)", xy=(x_object/2, t_object/2), xytext=(x_object/2 + 1, t_object/2 + 1),
            arrowprops=dict(facecolor='blue', arrowstyle="->"), fontsize=12, color='blue')

# Label and annotate
ax.text(x_object + 0.5, t_object, r"$(x, t)$", fontsize=12, color="blue")
ax.text(x_object/2 + 1, -0.5, "Space (x)", ha="center", fontsize=12)
ax.text(0.5, t_object/2 + 1, "Time (t)", ha="center", rotation=90, fontsize=12)
ax.text(x_object - 3, t_object + 1, r"$s = \sqrt{c^2 t^2 - x^2}$", fontsize=12, color="blue")

# Set axis limits and labels
ax.set_xlim(-10, 10)
ax.set_ylim(-10, 10)
ax.set_xlabel("Space (x)", fontsize=12)
ax.set_ylabel("Time (t)", fontsize=12)

# Legend and display adjustments
ax.legend(loc="upper left")
ax.axhline(0, color='black',linewidth=0.5)
ax.axvline(0, color='black',linewidth=0.5)

plt.show()
```

```{python}
#| label: corrected_worldlines_lightcone
#| fig-cap: "Minkowski Space: Worldlines for Stationary and Moving Observers"
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns


# Create figure and axis
fig, ax = plt.subplots(figsize=(8, 8))

# Generate time values
t = np.linspace(-5, 5, 100)

# Plot light cone (x = ±t)
ax.plot(t, t, '--', color='orange', label='Light Cone: $x = ct$')
ax.plot(t, -t, '--', color='orange')

# Plot stationary observer's worldline (x = 0)
ax.plot([0, 0], [-5, 5], color='blue', lw=2, label='Stationary Observer (v = 0)')

# Plot worldline for v = 0.3c
v1 = 0.3  # Velocity = 0.3c
x1 = v1 * t  # Worldline for v = 0.3c
ax.plot(x1, t, '--', color='blue', lw=2, label='Worldline (v = 0.3c)', alpha=0.75)

# Plot worldline for v = 0.9c
v3 = 0.6  # Velocity = 0.9c
x3 = v3 * t  # Worldline for v = 0.9c
ax.plot(x3, t, '--', color='blue', lw=2, label='Worldline (v = 0.6c)', alpha=0.5)

# Plot worldline for v = 0.9c
v2 = 0.9  # Velocity = 0.9c
x2 = v2 * t  # Worldline for v = 0.9c
ax.plot(x2, t, '--', color='blue', lw=2, label='Worldline (v = 0.9c)', alpha=0.25)

# Set plot limits, labels, and title
ax.set_xlim(-5, 5)
ax.set_ylim(-5, 5)
ax.set_xlabel('Space ($x$)')
ax.set_ylabel('Time ($t$)')
ax.set_title('Minkowski Space: Worldlines for Different Velocities')

# Add legend
ax.legend(loc='upper left')

# Show plot
plt.show()

```



# Glossary

- **Momentum** is the quantity of motion an object has—a measure of how hard it is to stop that object. Mathematically, it's $p = mv$, where $p$ is momentum, $m$ is mass, and $v$ is velocity.
- **Force** is any interaction that causes an object to change its motion (accelerate or decelerate). Newton's Second Law defines force as $F = ma$, where $F$ is the force, $m$ is mass, and $a$ is acceleration.
- **Energy** is the capacity to do work. It exists in various forms, such as kinetic energy, potential energy, thermal energy, etc. In mechanics, the most common types are:
  - **Kinetic Energy** is the energy an object has due to its motion: $K = \frac{1}{2}mv^2$.
  - **Potential Energy** is the energy an object has due to its position in a force field, such as gravitational potential energy $U = mgh$ for an object in Earth's gravitational field.
- **Work** is the process of energy transfer when a force is applied to an object and it moves: $W = F \cdot d \cdot \cos(\theta)$, where $F$ is the force, $d$ is the displacement, and $\theta$ is the angle between the force and displacement vectors.
- **Newton's Laws of Motion**:
  - **First Law (Inertia):** An object will remain at rest or in uniform motion unless acted upon by an external force.
  - **Second Law:** The acceleration of an object is proportional to the net force acting on it and inversely proportional to its mass: $F = ma$.
  - **Third Law:** For every action, there is an equal and opposite reaction.
- **Maxwell's Equations** describe how electric and magnetic fields interact and propagate:
  - **Gauss's Law:** The electric flux through a closed surface is proportional to the charge enclosed.
  - **Gauss's Law for Magnetism:** Magnetic monopoles do not exist; the magnetic flux through a closed surface is zero.
  - **Faraday's Law of Induction:** A changing magnetic field induces an electric field.
  - **Ampère's Law (with Maxwell's correction):** Magnetic fields can be generated by electric currents and changing electric fields.
- **Lagrangian Mechanics** is a reformulation of classical mechanics based on the principle of least action. The **Lagrangian** $L$ is defined as the difference between kinetic and potential energy: $L = T - U$. It leads to the Euler-Lagrange equations, which describe the dynamics of a system.
- **Hamiltonian Mechanics** is another reformulation of classical mechanics, focused on energy conservation. The **Hamiltonian** $H$ is the total energy of the system (kinetic plus potential energy): $H = T + U$. It uses a set of equations called Hamilton's equations to describe the evolution of a system over time.
- **Minkowski Space** is a four-dimensional space combining three-dimensional space with time into a single manifold, used in the theory of special relativity. It allows for a unified treatment of space and time with the **spacetime interval**: $s^2 = (ct)^2 - x^2 - y^2 - z^2$, where $c$ is the speed of light. Note how $ct$ makes the units consistent.
- **Einstein's Theory of Special Relativity** states that the laws of physics are the same in all inertial frames, and that the speed of light in a vacuum is constant. This leads to the famous equation $E = mc^2$, which relates mass and energy. 
- **Einstein's Theory of General Relativity** generalizes special relativity to include gravity. It describes _gravity not as a force_ but as the curvature of spacetime caused by mass and energy. Objects follow geodesics, the shortest paths, in this curved spacetime.
