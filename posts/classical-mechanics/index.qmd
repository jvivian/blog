---
title: "Pythagorean Time Dilation"
subtitle: "A Summary of Classical Mechanics"
author: John Vivian
date: 2024-10-15
format: 
  html:
    # css: styles.css
    toc: true
    toc-depth: 2
    echo: false
editor: visual
execute:
  render-on-save: true
tools:
  - mermaid
---
```{python}
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

plt.style.use('ggplot')
```

# A Journey Through (Space)Time
> _I do not know what I may appear to the world, but to myself I seem to have been only like a boy playing on the sea-shore, and diverting myself in now and then finding a smoother pebble or a prettier shell than ordinary, whilst the great ocean of truth lay all undiscovered before me_ [^1]

This overview is roughly structured by the concepts I found most profound while reading and researching topics in Sean Carroll's book _The Biggest Ideas in The Universe: Space, Time, and Motion_

- While velocity only has meaning in other reference frames, acceleration is _absolute_, and can be identified intriniscally without one (in most cases).
- The squared term in the inverse square law is derived from the spacial geometry we live in (three dimensions).
- Magnetism only exists as a relativistic effect when an object moves relative to an electric field, which helps explain why we have never observed a magnetic monopole.
- The path a particle or system takes is always the most "economical" route through spacetime (via minimization/maximization of **action**)
- Conservation laws arise directly from symmetries in the laws of physics. I.e. The invariance of a system's laws relate directly to a given conservation law: time invariance $\rightarrow$ energy conservation, spatial invariance $\rightarrow$ momentum conservation, and rotational symmetry $\rightarrow$ angular momentum conservation.
- The speed of light, $c$, provides a conversion factor between time and space. Like energy $\Leftrightarrow$ mass and electricity $\Leftrightarrow$ magnetism, they are aspects of the same phenomena.
- Schwartzchild's solution to General Relativity contained a mathematical singularity -- originally thought to be a _coordinate singularity_ -- turned out to be a real _curvature singularity_ in spacetime: a blackhole.

# Acceleration is Absolute

[^1]: Isaac Newton. "Anecdotes, Observations and Characters, of Books and Men" Vol 1 (page 158). Spence, J. 1820.

Imagine yourself in space with no nearby objects, only distant stars; would it be possible to tell you are moving? Nope. As Einstein later proved, velocity only has context relative to another reference frame. Two people moving in in the same environment past each other would not be able to conclude whether one person was stationary and the other was moving or if both people are moving.

Oddly, _acceleration_ is not the same. If you were suddenly accelerated while in the space suit you would feel it; you would jerk forward, feel the suit push against your chest, etc. The reason for this is acceleration produces a _force gradient_, as opposed to velocity which does not require a force to keep you moving (an object in motion, yada yada...).

You can build your own accelerator-detector just by hanging a weight from a spring. If you begin accelerating left or right, the spring would stretch in the opposite direction. The weight needs to hang to work, because if you turn it sideways the weight will fall towards the ground, even if remain perfectly still. You _are_ accelerating, and have been for quite some time, directly towards the center of the planet. We experience this acceleration as _weight_, which is canceled out by the normal force of the planet pushing back up against us. 


```{python}
#| label: fig-spring_weight_visualization
#| fig-cap: "Spring with hanging weight, which stretches to the left if accelerated to the right."
# Parameters for the spring and weight
k = 50  # Spring constant (N/m)
mass = 1.0  # Mass of the weight (kg)
g = 9.81  # Gravitational acceleration (m/s^2)
equilibrium_length = 2.0  # Length of the spring with no weight (m)

# Calculate the displacement due to the weight
stretch = mass * g / k  # Stretch caused by the weight

# Create the spring curve using sine waves for aesthetics
def spring_curve(x: np.ndarray, stretch: float) -> np.ndarray:
    """Creates a wavy curve representing the spring."""
    return np.sin(10 * np.pi * x) * 0.1 - x * stretch

# Generate the spring curve before and after stretching
x = np.linspace(0, 1, 500)  # x-axis points along the spring
y_unstretched = spring_curve(x, 0)  # Unstretched spring
y_stretched = spring_curve(x, stretch)  # Stretched spring

# Create the figure and axis
fig, ax = plt.subplots(figsize=(6, 8))

# Plot the unstretched and stretched spring curves
ax.plot(y_unstretched, -x * equilibrium_length, 'k--', alpha=0.5, label='Unstretched Spring')
ax.plot(y_stretched, -x * (equilibrium_length + stretch), 'b-', label='Stretched Spring')

# Plot the weight as a black circle
ax.plot(0, -(equilibrium_length + stretch), 'ro', markersize=15, label='Weight')

# Plot the gravitational force vector (downward)
ax.arrow(0, -(equilibrium_length + stretch), 0, -0.5, head_width=0.1, head_length=0.1, 
         fc='blue', ec='blue', label='Gravitational Force $F_g$')

# Plot the spring force vector (upward)
ax.arrow(0, -(equilibrium_length + stretch), 0, 0.5, head_width=0.1, head_length=0.1, 
         fc='green', ec='green', label='Spring Force $F_s$')

# Set plot limits and labels
ax.set_xlim(-0.5, 0.5)
ax.set_ylim(-3.5, 0.5)
ax.set_xlabel('Spring Width')
ax.set_ylabel('Height')
# ax.set_title('Spring with Hanging Weight Demonstrating Acceleration')

# Add legend
ax.legend(loc='upper right')

# Display the plot
plt.show()
```

Physics equations are incredible because they describe _universal relationships_ about the world we've found ourselves in. For example, the _momentum_ of an object is described by its mass and velocity: $p = mv$. This relationship applies to _every_ object of mass that can have a velocity. And I think that's pretty neat [^2]. This equation also states that momentum is proportional to velocity given constant mass. Doubling the velocity of an object doubles its momentum.

[^2]: Neature Walk: https://www.youtube.com/watch?v=Hm3JodBR-vs

## Kinematic Equations
> Moving Through Time: Universal Relationships of Motion

These equations describe universal relationships about an object's motion with constant acceleration—useful for predicting where or how fast something will be at a given time. 

$$v = v_0 + at$$

Velocity increases linearly with time when acceleration is constant

$$s = s_0 + v_0 t + \frac{1}{2} at^2$$

Position grows with time, influenced by both your initial speed and the acceleration 

$$v^2 = v_0^2 + 2a(s - s_0)$$  

The relationship between velocity and distance, without needing time

An interesting consequence to these equations is given position or velocity as a function of time, the equation will predict the function's value for whatever $t$ is. Meaning, these universal relationships do not operate as if the past (fixed from our perspective) is fundamentally different from the future (not-fixed, from our perspective).

::: {.callout-tip collapse="true"}
## What's the point of calculus
Calculus solves two limit-based problems:

1. The goal of the derivative is to find $\frac{dx}{dt}$ as they both approach zero, but you can't divide by zero.
2. The integral attempts to find the sum of the area under the curve as the number of riemann squares approaches infinity.

You can expand a small change in a simple function (such as $x^2$, i.e. $(x+h)^2 - x^2$) and work out as the limit $h \rightarrow 0$, you get $2x$.
:::

:::{.callout-note collapse="true"}
## Kinematic Derivation
The kinematic equations can be derived from the basic definition of calculus. Given a change in position over time is velocity:
$$\frac{dx}{dt} = v$$

we want to express $v$ in terms of $t$, since that also changes over time.

$$v(t) = v_0 + at$$

Reformulate velocity as the first time derivative of position

$$\frac{dx}{dt} = v_0 + at$$

Then integrate with respect to time

$$x(t) = \int (v_0 + at) dt$$

Solving for the integral gives us

$$x(t) = v_0t + \frac{1}{2}at^2 + C$$

Where C would represent whatever the **initial position** is, which we can call $x_0$. This gives us

$$x(t) = x_0 + v_0t + \frac{1}{2}at^2$$

You can plug this equation into $v = v_0 + at$ and do some math to get:

$$v^2 = v_0^2 + 2a(x-x0)$$
:::

## The Universal Law of Gravitation

```{python}
#| label: fig-gravitational_force_visualization
#| fig-cap: Force vectors (equal and opposite for each mass) generated as a result of their respective masses and distance.
# Gravitational constant (arbitrary scale for visualization)
G = 1.0

# Masses of two objects
m1 = 6.0  # Mass of first object
m2 = 2.0  # Mass of second object

# Positions of the two masses
x1, y1 = -1, 0  # Position of mass 1
x2, y2 = 1, -2   # Position of mass 2

# Distance between the two masses
r = round(np.sqrt((x2 - x1)**2 + (y2 - y1)**2), 2)

# Calculate the force magnitude using Newton's law of gravitation
F = G * (m1 * m2) / r**2

# Unit vector for the direction of the force
dx, dy = (x2 - x1) / r, (y2 - y1) / r

# Create the figure and axis
fig, ax = plt.subplots(figsize=(8, 6))

# Plot the two masses as circles
ax.plot(x1, y1, 'ro', markersize=m1 * 5, label=f'$m_1$: {m1}')
ax.plot(x2, y2, 'bo', markersize=m2 * 5, label=f'$m_2$: {m2}')

# Plot force vectors (equal and opposite)
ax.arrow(x1, y1, F * dx, F * dy, head_width=0.1, head_length=0.2, 
         fc='red', ec='red', label='Gravitational Force on $m_1$')
ax.arrow(x2, y2, -F * dx, -F * dy, head_width=0.1, head_length=0.2, 
         fc='blue', ec='blue', label='Gravitational Force on $m_2$')

# Set plot limits
# ax.set_xlim(-3, 3)
# ax.set_ylim(-2, 2)

# Add labels, title, and legend
ax.set_xlabel('x')
ax.set_ylabel('y')
# ax.set_title(f"Gravitational force vectors - Distance: {r}")
ax.legend(loc='upper right')

# Display the plot
plt.show()
```

Newton's Universal Law of Gravitation describes the generated by two masses. This equation also ties together the inverse square law (decay of intensity of effects such as light, radiation, or gravity). 

$$F = G\frac{m_1m_2}{r^2}$$

- $F$ is the gravitational force between two masses.
- $G$ is the gravitational constant.
- $m_1$ and $m_2$ are the masses of the two objects.
- $r$ is the distance between the centers of the two masses.

Why is $r$ squared? Why not quadrupled or halved? The inverse square relationship emerges as a property of living in three dimensions. The volume of a sphere increases with the square of the radius: $4\pi r^2$.

# Maxwell's Equations
> Quote here

Maxwell's Equations elegantly describe the behavior of electric and magnetic fields, revealing that these two forces are not separate but deeply interconnected. They provide a unified framework for understanding how electric charges and currents create fields that interact, propagate, and influence each other, ultimately giving rise to light itself. 

## **Gauss's Law (Electric Field)**

$$\nabla \cdot \mathbf{E} = \frac{\rho}{\epsilon_0}$$

:::{.callout-note collapse="true"}
## Understanding the Del Operator ($\nabla$) in Maxwell’s Equations

The **del operator** ($\nabla$) is a vector operator that captures how quantities change in space, and it’s central to expressing Maxwell’s equations in a compact, powerful form. 

1. **Gradient ($\nabla \phi$)**: When applied to a scalar field $\phi$, $\nabla$ (del) gives the **gradient**, pointing in the direction of the greatest rate of change. For example, in an electric potential field $\phi$, the gradient $\vec{E} = -\nabla\phi$ tells us how the electric field varies in space.

2. **Divergence ($\nabla \cdot$)**: When $\nabla$ is applied to a vector field with a dot product ($\nabla \cdot$), it gives the **divergence**. Divergence measures the “outflow” or “inflow” of a field at a point:
   - **Gauss’s Law for Electricity** $(\nabla·\vec{E} = \frac{ρ}{ε_0})$: This tells us that the electric field $\vec{E}$ diverges from electric charges.
   - **Gauss’s Law for Magnetism** $(\nabla·\vec{B} = 0)$: This shows that magnetic field lines have no divergence—they form closed loops, indicating no magnetic monopoles.

3. **Curl ($\nabla \times$)**: When $\nabla$ is applied to a vector field with a cross product ($\nabla \times$), it gives the **curl**, measuring the “rotation” or “circulation” of a field:
   - **Faraday’s Law** $(\nabla×\vec{E} = -\frac{∂\vec{B}}{∂t})$: A changing magnetic field $\vec{B}$ induces a circulating electric field $\vec{E}$.
   - **Ampère’s Law (with Maxwell’s Correction)** $(\nabla×\vec{B} = μ_0\vec{J} + μ_0ε_0\frac{∂\vec{E}}{∂t})$: A changing electric field $\vec{E}$ or current density $\vec{J}$ induces a circulating magnetic field $\vec{B}$.

### Summary:
The del operator ($\nabla$) is a vector operator that operates on a:
- **Gradient ($\nabla\phi$)**: scalar field, producing a vector field.
- **Divergence ($\nabla\cdot$)**: vector field, producing a scalar field.
- **Curl ($\nabla\times$)**: vector field, producing a vector field.
:::


Gauss's Law describes the relationship between electric charges and the electric field they produce. Specifically, it states that the electric flux (the "flow" of the electric field) through a closed surface is proportional to the total charge enclosed within that surface. For example, the electric field around a point charge (like an electron) points away from the charge if it's positive, and towards the charge if it's negative. The strength of the field is directly related to the amount of charge.

- $\nabla \cdot \mathbf{E}$: This is the divergence of the electric field $\mathbf{E}$, which essentially measures how much the electric field is "spreading out" from a point.
- $\rho$: This represents the **charge density** (charge per unit volume). The more charge you have in a given region, the stronger the electric field diverges from that region.
- $\epsilon_0$: This is the **permittivity of free space**, a constant that determines how electric fields interact in a vacuum.

```{python}
#| label: fig-gauss_law_electric
#| fig-cap: "Gauss's Law for Electricity: Electric Field Lines Around Charges"
# Create a grid for the field
x, y = np.meshgrid(np.linspace(-2, 2, 400), np.linspace(-2, 2, 400))

# Define charge positions and magnitudes (positive and negative)
charges = [(1, (0.5, 0)), (-1, (-0.5, 0))]

# Initialize the electric field vectors
Ex, Ey = np.zeros(x.shape), np.zeros(y.shape)

# Loop over the charges and calculate the contribution to the field
for charge, (cx, cy) in charges:
    r = np.sqrt((x - cx)**2 + (y - cy)**2)
    Ex += charge * (x - cx) / r**3
    Ey += charge * (y - cy) / r**3

# Plot the electric field lines
plt.figure(figsize=(6, 6))
plt.streamplot(x, y, Ex, Ey, color=np.sqrt(Ex**2 + Ey**2), linewidth=1)
plt.plot(0.5, 0, 'ro', markersize=10, label='Positive Charge')
plt.plot(-0.5, 0, 'bo', markersize=10, label='Negative Charge')

# Labels and title
plt.title("Gauss's Law for Electricity")
plt.legend()
plt.show()
```


##  **Gauss's Law for Magnetism**

$$\nabla \cdot \mathbf{B} = 0$$

This law states that there are **no magnetic monopoles** — that is, no isolated north or south magnetic poles. Magnetic fields ($\mathbf{B}$) always form closed loops. Every magnetic field line that leaves a north pole must eventually return to a south pole.

- $\nabla \cdot \mathbf{B}$: This is the divergence of the magnetic field $\mathbf{B}$, which measures how much the magnetic field is "spreading out" from a point.
- The fact that it's equal to zero means that the net magnetic "flux" through any closed surface is always zero, implying that magnetic field lines don’t begin or end at any point (unlike electric fields, which start or end on charges).

```{python}
#| label: fig-magnetic
#| fig-cap: Magnetic field lines around a magnetic point

# Grid for the contour plot
x = np.linspace(-3, 3, 100)
y = np.linspace(-3, 3, 100)
X, Y = np.meshgrid(x, y)

# Calculate a hypothetical magnetic dipole field in 2D for visualization
# Assuming a simple dipole approximation
B_x = -Y / (X**2 + Y**2)**1.5  # Field component in x direction
B_y = X / (X**2 + Y**2)**1.5  # Field component in y direction

# Magnitude of the field for contour levels
B_magnitude = np.sqrt(B_x**2 + B_y**2)

# Create the contour plot
fig, ax = plt.subplots(figsize=(8, 8))

# Plot the field lines as contours
contour = ax.contour(X, Y, B_magnitude, levels=10, cmap="viridis", alpha=0.75)
ax.clabel(contour, inline=True, fontsize=8, fmt="%.2f")

# Add streamplot to show the direction of the magnetic field
ax.streamplot(X, Y, B_x, B_y, color="darkred", linewidth=1, density=1.5, arrowsize=1.5)

# Plot Gaussian surface as a dashed circle to emphasize the zero net flux
surface_radius = 2.5
theta = np.linspace(0, 2 * np.pi, 100)
x_surface = surface_radius * np.cos(theta)
y_surface = surface_radius * np.sin(theta)
ax.plot(x_surface, y_surface, 'k--', label="Gaussian Surface")

# Annotate the North and South poles for reference
ax.text(0, 2.8, "N", ha='center', va='center', fontsize=14, color='blue')
ax.text(0, -2.8, "S", ha='center', va='center', fontsize=14, color='blue')

# Labels, legend, and aesthetic adjustments
ax.legend(loc="upper right")
ax.axis("equal")
ax.axis("off")

# Display the plot
plt.show()
```


## **Faraday's Law of Induction**
$$\nabla \times \mathbf{E} = -\frac{\partial \mathbf{B}}{\partial t}$$

**Meaning:**
Faraday’s Law explains how a changing magnetic field creates an electric field. If you have a time-varying magnetic field ($\mathbf{B}$), it induces a circulating electric field ($\mathbf{E}$). This is the principle behind electromagnetic induction, which is used in transformers and electric generators. When a magnet is spun around near a coil of wire, the changing magnetic field induces an electric current in the wire, which we can then use as electrical power.

- **$\nabla \times \mathbf{E}$**: This is the curl of the electric field $\mathbf{E}$, which measures how much the electric field is "circulating" around a point.
- **$\frac{\partial \mathbf{B}}{\partial t}$**: This is the time rate of change of the magnetic field. It represents how the magnetic field is changing in time.
- The negative sign indicates that the induced electric field opposes the change in the magnetic field (this is Lenz's law).

```{python}
#| label: fig-faraday
#| fig-cap: Changing magnetic fields induce electric fields

import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

# Set up the figure and 3D axes with ggplot style
plt.style.use('ggplot')
fig = plt.figure(figsize=(10, 6))
ax = fig.add_subplot(111, projection='3d')

# Parameters for the waves
x = np.linspace(0, 20, 1000)  # Position along the propagation direction (x-axis)
k = 2 * np.pi / 5             # Wave number
omega = 2 * np.pi / 5         # Angular frequency
t = 0                         # Time (static snapshot)
E0 = 1                        # Electric field amplitude
B0 = 1                        # Magnetic field amplitude

# Calculate the electric and magnetic fields as sinusoidal waves
E = E0 * np.sin(k * x - omega * t)  # Electric field (along y-axis)
B = B0 * np.sin(k * x - omega * t)  # Magnetic field (along z-axis)

# Plot the electric field
ax.plot(x, E, np.zeros_like(x), color='blue', label='Electric Field (E)', linewidth=2)
# Plot the magnetic field
ax.plot(x, np.zeros_like(x), B, color='red', label='Magnetic Field (B)', linewidth=2)

# Add a dotted arrow along the x-axis to represent the direction of wave propagation
ax.plot(x, np.zeros_like(x), np.zeros_like(x), 'k--', label='Propagation Direction (x)', linewidth=1.5)

# Customize the view angle for a clear perspective
ax.view_init(elev=30, azim=60)

# Labels and legend for clarity
ax.set_xlabel('Propagation Direction (x)', fontsize=12)
ax.set_ylabel('Electric Field (E)', fontsize=12)
ax.set_zlabel('Magnetic Field (B)', fontsize=12)
ax.legend(fontsize=12)

# Minimalist aesthetics: turn off grid panes for a cleaner look
ax.grid(False)
ax.xaxis.pane.fill = False
ax.yaxis.pane.fill = False
ax.zaxis.pane.fill = False
ax.xaxis.pane.set_edgecolor('w')
ax.yaxis.pane.set_edgecolor('w')
ax.zaxis.pane.set_edgecolor('w')
ax.set_xticks([])
ax.set_yticks([])
ax.set_zticks([])

# Show the plot
plt.tight_layout()
plt.show()
```


## **Ampère's Law (with Maxwell’s Correction)**

$$\nabla \times \mathbf{B} = \mu_0 \mathbf{J} + \mu_0 \epsilon_0 \frac{\partial \mathbf{E}}{\partial t}$$

Ampère’s Law relates electric currents and changing electric fields to the magnetic field they produce. It says that magnetic fields can be generated in two ways:
- By electric currents (moving charges), as described by the first term, $\mu_0 \mathbf{J}$.
- By changing electric fields, as described by the second term, $\mu_0 \epsilon_0 \frac{\partial \mathbf{E}}{\partial t}$, which is called the **displacement current** (introduced by Maxwell).

- $\nabla \times \mathbf{B}$: This is the curl of the magnetic field $\mathbf{B}$, which measures how much the magnetic field "circulates" around a point.
- $\mathbf{J}$: This is the **current density** (current per unit area).
- $\frac{\partial \mathbf{E}}{\partial t}$: This represents the rate of change of the electric field in time.

Ampère’s Law with Maxwell’s correction tells us that **currents** (moving charges) and **changing electric fields** generate magnetic fields. Without the time-dependent term $\frac{\partial \mathbf{E}}{\partial t}$, this would just be the original Ampère’s Law, which describes how an electric current creates a magnetic field (like in an electromagnet). Maxwell’s addition was crucial because it showed that even in the absence of a physical current, a changing electric field can still produce a magnetic field.

```{python}
#| label: fig-ampere
#| fig-cap: The opposite of Faraday's Law - a time-varying electric field is the source of an induced magnetic field.
# Re-plotting with only "dE/dt" to emphasize the time-varying electric field as the source of the induced magnetic field

# Set up the figure with ggplot style for aesthetics
fig, ax = plt.subplots(figsize=(8, 8))
ax.set_aspect('equal')

# Define parameters for the capacitor plates and electric field lines
plate_width = 1.0
plate_length = 4.0
plate_offset = 1.5

# Plot the capacitor plates with color-coded charges
ax.plot([-plate_length / 2, plate_length / 2], [plate_offset, plate_offset], color='red', lw=4, label="Capacitor Plate (+)")
ax.plot([-plate_length / 2, plate_length / 2], [-plate_offset, -plate_offset], color='black', lw=4, label="Capacitor Plate (-)")

# Electric field lines between capacitor plates (vertical lines indicating field change)
for i in np.linspace(-plate_length / 2, plate_length / 2, 6):
    ax.arrow(i, -plate_offset, 0, 2 * plate_offset, head_width=0.1, head_length=0.2, fc='blue', ec='blue')

# Magnetic field lines (circling the changing electric field in the gap)
theta = np.linspace(0, 2 * np.pi, 100)
for radius in [2.2, 2.7, 3.2]:  # Multiple circles for the magnetic field lines
    x = radius * np.cos(theta)
    y = radius * np.sin(theta)
    ax.plot(x, y, color='orange', linestyle='--', lw=1.5, alpha=0.8, label="Induced Magnetic Field" if radius == 2.2 else "")

# Annotation to highlight the changing electric field (dE/dt)
ax.text(0, -plate_offset - 0.5, "dE/dt (Changing Electric Field)", ha='center', color='blue', fontsize=12)
ax.text(3.5, 0, "B (Induced Magnetic Field)", color='orange', fontsize=12, rotation=90)

# Minimalist aesthetics
ax.axis("off")
ax.legend(loc="upper right")

# Display the plot
plt.tight_layout()
plt.show()
```

### The Bigger Picture: Electromagnetic Waves
Maxwell’s equations, taken together, explain how electric and magnetic fields interact and propagate. If you combine Faraday's Law and Ampère’s Law, you can derive the **wave equation** for both electric and magnetic fields, showing that disturbances in these fields propagate at the speed of light. Together, these two effects allow electromagnetic waves to propagate through space, with the electric and magnetic fields continuously regenerating each other.

This is why light, radio waves, X-rays, and all other electromagnetic radiation are essentially **electromagnetic waves**: oscillating electric and magnetic fields that move through space, even in a vacuum.


# Lagrangian and Hamiltonian Mechanics
> Different ways to tell the same (Newtonian) story

Instead of forces and acceleration, Lagrangian and Hamiltonian mechanics focuses on _paths, energy, and phase space_. The last is particularly useful for understanding field theory.

```{python}
#| label: fig-corrected_mechanics_comparison
#| fig-cap: "Comparison of Newtonian, Lagrangian, and Hamiltonian Mechanics for a simple harmonic oscillator"
from scipy.integrate import solve_ivp
# Parameters for the harmonic oscillator
m = 1.0   # Mass (kg)
k = 1.0   # Spring constant (N/m)
omega = np.sqrt(k / m)  # Angular frequency
A = 1.0  # Amplitude of oscillation

# Newtonian mechanics: F = ma = -kx
def newtonian_acceleration(x: np.ndarray) -> np.ndarray:
    return -omega**2 * x

# Hamiltonian mechanics: Phase space dynamics
def hamiltonian_system(t: float, y: np.ndarray) -> np.ndarray:
    q, p = y  # Position and momentum
    dqdt = p / m  # dx/dt = p / m
    dpdt = -k * q  # dp/dt = -kx
    return [dqdt, dpdt]

# Solve Hamiltonian system for phase space trajectory
sol = solve_ivp(hamiltonian_system, [0, 10], [A, 0], t_eval=np.linspace(0, 10, 500))

# Lagrangian path: Position over time assuming maximum displacement at t=0
time = np.linspace(0, 10, 100)
x_lagrangian = A * np.cos(omega * time)  # Expected path for least action

# Create figure with subplots
fig, axs = plt.subplots(3, figsize=(8, 10))

# 1. Newtonian mechanics: Acceleration vs. Position
x = np.linspace(-A, A, 100)  # Position range for the oscillator
axs[0].plot(x, newtonian_acceleration(x), color='blue')
axs[0].set_title('Newtonian Mechanics: F = ma')
axs[0].set_xlabel('Position ($x$)')
axs[0].set_ylabel('Acceleration ($a$)')
axs[0].axhline(0, color='black', lw=0.8)  # Equilibrium acceleration line

# 2. Lagrangian mechanics: Path over time
axs[1].plot(time, x_lagrangian, color='green')
axs[1].set_title('Lagrangian Mechanics: Path Minimization')
axs[1].set_xlabel('Time ($t$)')
axs[1].set_ylabel('Position ($x$)')
axs[1].axhline(0, color='black', lw=0.8)  # Equilibrium line

# 3. Hamiltonian mechanics: Phase space trajectory
axs[2].plot(sol.y[0], sol.y[1], color='red')
axs[2].set_title('Hamiltonian Mechanics: Phase Space')
axs[2].set_xlabel('Position ($q$)')
axs[2].set_ylabel('Momentum ($p$)')
axs[2].axhline(0, color='black', lw=0.8)  # Zero momentum line
axs[2].axvline(0, color='black', lw=0.8)  # Zero position line

# Adjust layout and display plot
plt.suptitle('Comparison of Newtonian, Lagrangian, and Hamiltonian Mechanics')
plt.tight_layout()
plt.show()

```

## The Action Integral
> The profound economy of Nature

The action integral $S$ is the "score" of a given path taken by a system between two points in time.

$$S[q(t)] = \int_{t_1}^{t_2} L(q, \dot{q}, t) \, dt$$

- $S[q(t)]$ is the _action_ which depends on the path $q(t)$
- $L(q, \dot{q}, t)$ is the **Lagrangian**, which is the difference between the kinetic energy $T$ and potential energy $V$
- Note: Dot notation above a variable represents its first derivative. Two dots for the second derivative.

$$L = T - V$$

The integral sums up $L$ along a specific path between $t_1$ and $t_2$



# Minkowski Space

```{python}
#| label: fig-minkowski_light_cone
#| fig-cap: Light Cone in Minkowski Space. A stationary observer moves vertically along a 'World Line'
fig, ax = plt.subplots(figsize=(8, 8))

# Plot the light cone (x = ±ct)
t = np.linspace(-5, 5, 100)
ax.plot(t, t, linestyle='--', color='orange', label='Light Cone: $x = ct$')
ax.plot(t, -t, linestyle='--', color='orange')

# Plot the observer's worldline (stationary at x = 0)
ax.plot([0, 0], [-5, 5], color='blue', lw=2, label='Worldline of Observer')

# Plot space and time axes
ax.axhline(0, color='black', lw=1)  # Space axis
ax.axvline(0, color='black', lw=1)  # Time axis

# Annotate causal regions
ax.text(2.5, 2.5, 'Future', fontsize=12, color='green', ha='center')
ax.text(-2.5, -2.5, 'Past', fontsize=12, color='red', ha='center')
ax.text(3.5, -0.5, 'Elsewhere', fontsize=12, color='gray', ha='center')

# Set labels and limits
ax.set_xlabel('Space ($x$)')
ax.set_ylabel('Time ($t$)')
ax.set_title('Minkowski Space: Light Cone of an Observer')

# Set plot limits for symmetry
ax.set_xlim(-5, 5)
ax.set_ylim(-5, 5)

# Add legend
ax.legend(loc='upper right')

# Display plot
plt.show()

```

```{python}
#| label: corrected_worldlines_lightcone
#| fig-cap: "Minkowski Space: Worldlines for Stationary and Moving Observers"
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns


# Create figure and axis
fig, ax = plt.subplots(figsize=(8, 8))

# Generate time values
t = np.linspace(-5, 5, 100)

# Plot light cone (x = ±t)
ax.plot(t, t, '--', color='orange', label='Light Cone: $x = ct$')
ax.plot(t, -t, '--', color='orange')

# Plot stationary observer's worldline (x = 0)
ax.plot([0, 0], [-5, 5], color='blue', lw=2, label='Stationary Observer (v = 0)')

# Plot worldline for v = 0.3c
v1 = 0.3  # Velocity = 0.3c
x1 = v1 * t  # Worldline for v = 0.3c
ax.plot(x1, t, '--', color='blue', lw=2, label='Worldline (v = 0.3c)', alpha=0.75)

# Plot worldline for v = 0.9c
v3 = 0.6  # Velocity = 0.9c
x3 = v3 * t  # Worldline for v = 0.9c
ax.plot(x3, t, '--', color='blue', lw=2, label='Worldline (v = 0.6c)', alpha=0.5)

# Plot worldline for v = 0.9c
v2 = 0.9  # Velocity = 0.9c
x2 = v2 * t  # Worldline for v = 0.9c
ax.plot(x2, t, '--', color='blue', lw=2, label='Worldline (v = 0.9c)', alpha=0.25)

# Set plot limits, labels, and title
ax.set_xlim(-5, 5)
ax.set_ylim(-5, 5)
ax.set_xlabel('Space ($x$)')
ax.set_ylabel('Time ($t$)')
ax.set_title('Minkowski Space: Worldlines for Different Velocities')

# Add legend
ax.legend(loc='upper left')

# Show plot
plt.show()

```



# Glossary

- **Momentum** is the quantity of motion an object has—a measure of how hard it is to stop that object. Mathematically, it's $p = mv$, where $p$ is momentum, $m$ is mass, and $v$ is velocity.
- **Force** is any interaction that causes an object to change its motion (accelerate or decelerate). Newton's Second Law defines force as $F = ma$, where $F$ is the force, $m$ is mass, and $a$ is acceleration.
- **Energy** is the capacity to do work. It exists in various forms, such as kinetic energy, potential energy, thermal energy, etc. In mechanics, the most common types are:
  - **Kinetic Energy** is the energy an object has due to its motion: $K = \frac{1}{2}mv^2$.
  - **Potential Energy** is the energy an object has due to its position in a force field, such as gravitational potential energy $U = mgh$ for an object in Earth's gravitational field.
- **Work** is the process of energy transfer when a force is applied to an object and it moves: $W = F \cdot d \cdot \cos(\theta)$, where $F$ is the force, $d$ is the displacement, and $\theta$ is the angle between the force and displacement vectors.
- **Newton's Laws of Motion**:
  - **First Law (Inertia):** An object will remain at rest or in uniform motion unless acted upon by an external force.
  - **Second Law:** The acceleration of an object is proportional to the net force acting on it and inversely proportional to its mass: $F = ma$.
  - **Third Law:** For every action, there is an equal and opposite reaction.
- **Maxwell's Equations** describe how electric and magnetic fields interact and propagate:
  - **Gauss's Law:** The electric flux through a closed surface is proportional to the charge enclosed.
  - **Gauss's Law for Magnetism:** Magnetic monopoles do not exist; the magnetic flux through a closed surface is zero.
  - **Faraday's Law of Induction:** A changing magnetic field induces an electric field.
  - **Ampère's Law (with Maxwell's correction):** Magnetic fields can be generated by electric currents and changing electric fields.
- **Lagrangian Mechanics** is a reformulation of classical mechanics based on the principle of least action. The **Lagrangian** $L$ is defined as the difference between kinetic and potential energy: $L = T - U$. It leads to the Euler-Lagrange equations, which describe the dynamics of a system.
- **Hamiltonian Mechanics** is another reformulation of classical mechanics, focused on energy conservation. The **Hamiltonian** $H$ is the total energy of the system (kinetic plus potential energy): $H = T + U$. It uses a set of equations called Hamilton's equations to describe the evolution of a system over time.
- **Minkowski Space** is a four-dimensional space combining three-dimensional space with time into a single manifold, used in the theory of special relativity. It allows for a unified treatment of space and time with the **spacetime interval**: $s^2 = (ct)^2 - x^2 - y^2 - z^2$, where $c$ is the speed of light. Note how $ct$ makes the units consistent.
- **Einstein's Theory of Special Relativity** states that the laws of physics are the same in all inertial frames, and that the speed of light in a vacuum is constant. This leads to the famous equation $E = mc^2$, which relates mass and energy. 
- **Einstein's Theory of General Relativity** generalizes special relativity to include gravity. It describes _gravity not as a force_ but as the curvature of spacetime caused by mass and energy. Objects follow geodesics, the shortest paths, in this curved spacetime.
